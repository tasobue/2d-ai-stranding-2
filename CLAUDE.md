# 開発方式

- アジャイル開発の思想で開発し、タスクリストのタスク単位で設計書、実装、テストコードの実装、テストを行う。
- タスク単位で処理を中断し、人間にタスク状況の報告とレビューをリクエストする。

# Git方針

- 新しいタスクを開始するとき、機能ブランチを作成する。
- タスクが完了したときにmainブランチへのプルリクエストを行う。
- タスク単位でGitにプッシュを行い、リリースを作成する。リリースノートも作成する。

# AIマップ生成ゲーム開発タスクリスト

## Phase 1: 最小動作版（1-2日）
### 🎯 目標：プレイヤーが動いてゴールに到達できる

#### Task 1.1: 基本セットアップ ✅
- [ ] Vite + React + Phaser.js 基本構成作成
- [ ] プロジェクト構造設定
- [ ] 画面サイズ設定（800x600推奨）

#### Task 1.2: 固定マップでの基本ゲーム
- [ ] 16x16のシンプルなグリッドマップ作成
- [ ] プレイヤーキャラクター（ドット絵）配置
- [ ] WASD/矢印キーでの8方向移動実装
- [ ] スタート地点（左上）とゴール地点（右下）配置
- [ ] ゴール到達時の「クリア」メッセージ表示

#### Task 1.3: 基本UI
- [ ] 現在位置表示
- [ ] ゴールまでの距離表示
- [ ] リスタートボタン

### ✅ Milestone 1: プレイヤーが移動してゴールできる

---

## Phase 2: シンプルAI生成（2-3日）
### 🎯 目標：毎回異なるマップが生成される

#### Task 2.1: 基本マップ生成アルゴリズム
- [ ] Seedrandomライブラリ導入
- [ ] ランダムシード生成機能
- [ ] グリッドベースの地形生成（草地/水/山）
- [ ] 歩ける/歩けない地形の定義

#### Task 2.2: スタート・ゴール配置ロジック
- [ ] マップ端にスタート地点をランダム配置
- [ ] スタートから最も遠い位置にゴール配置
- [ ] 到達可能性チェック（簡易版）

#### Task 2.3: 地形多様性の実装
- [ ] 3-4種類の地形タイプ実装
  - 草地（通常速度）
  - 砂地（やや遅い）
  - 岩場（遅い）
  - 水（通行不可）
- [ ] ペーリンノイズライブラリ導入
- [ ] 自然な地形生成アルゴリズム

### ✅ Milestone 2: 毎回違うマップが自動生成される

---

## Phase 3: 経路複雑性向上（3-4日）
### 🎯 目標：戦略的な経路選択が必要なマップ

#### Task 3.1: 障害物システム
- [ ] 森林エリア（迂回が必要）
- [ ] 川・湖システム（橋で渡る）
- [ ] 山脈（峠道でのみ通行可能）

#### Task 3.2: パスファインディング
- [ ] A*アルゴリズム簡易実装
- [ ] ゴールまでの経路が必ず存在することを保証
- [ ] 複数ルート存在チェック

#### Task 3.3: 地形連結性改善
- [ ] 島状地形の防止
- [ ] 自然な川の流れ生成
- [ ] 山脈の連続性確保

### ✅ Milestone 3: 複雑で戦略的なマップ生成

---

## Phase 4: 視覚的美しさ向上（2-3日）
### 🎯 目標：ドット絵の美しいマップ

#### Task 4.1: ドット絵アセット作成
- [ ] 地形タイルセット制作（16x16 or 32x32）
- [ ] プレイヤーキャラクタースプライト
- [ ] ゴールマーカーアニメーション

#### Task 4.2: タイル自動選択システム
- [ ] 隣接タイルによるオートタイル実装
- [ ] 地形境界の自然な描画
- [ ] コーナータイル・エッジタイルシステム

#### Task 4.3: 視覚エフェクト
- [ ] 水面のアニメーション
- [ ] 草地の風揺れエフェクト
- [ ] プレイヤー移動時のパーティクル

### ✅ Milestone 4: 視覚的に美しいゲーム完成

---

## Phase 5: ポリッシュ・拡張（継続開発）
### 🎯 目標：完成度向上

#### Task 5.1: ゲーム体験向上
- [ ] BGM・効果音追加
- [ ] マップサイズ選択機能
- [ ] 難易度設定（Easy/Normal/Hard）
- [ ] タイム計測・ベストタイム記録

#### Task 5.2: AI生成パラメータ調整
- [ ] 地形密度調整スライダー
- [ ] 経路複雑さ調整
- [ ] シード値入力・共有機能

#### Task 5.3: 追加要素
- [ ] 中間チェックポイント
- [ ] 収集アイテム配置
- [ ] 天候変化システム

---

## 技術的実装メモ

### 推奨ライブラリ構成
```javascript
// 必須 ✅
- Phaser.js 3.x（ゲームエンジン）
- TypeScript（型安全性）
- nodemon + ts-node（開発環境）
- http-server（ローカルサーバー）

// Phase 2で追加予定
- seedrandom（再現可能な乱数）
- simplex-noise（地形生成）

// Phase 3で追加予定
- pathfinding.js（経路探索）

// Phase 4で追加予定
- Aseprite（ドット絵作成ツール）
```

### 開発環境セットアップ完了 ✅
- Node.js + TypeScript プロジェクト初期化
- Phaser.js 3.90.0 インストール
- 開発用スクリプト設定（build, dev, serve）
- 基本的なゲームシーン作成
- Git設定とリモートプッシュ完了


# 開発ルール

## 重要なルール
**⚠️ 毎回タスクが完了したときは、必ずこのclaude.mdファイルを最新化してください。**

- 新しい機能を追加した場合は、対応する箇所を更新
- 開発状況（完了済み/進行中/今後の予定）を常に最新に保つ
- 重要な設計変更があった場合は概要を更新
- 新しいコマンドや設定項目を追加した場合は該当セクションを更新

## コーディング規約
TypeScriptで保守性・可読性を高めるコード規約を以下に示します：

### 命名規則
• 変数・関数名はcamelCaseを使用し、意味が明確で動詞を含む名前にする（例：`getUserData`、`isValidEmail`）
• 定数は`UPPER_SNAKE_CASE`で定義し、magic numberを避ける
• インターfaces名は`I`プレフィックスを避け、PascalCaseで意味を表現する（例：`User`、`ApiResponse`）
• 型名は`Type`サフィックスを使用し、ジェネリック型には`T`、`U`、`K`などの単文字を使用する

### 型定義
• `any`型の使用を避け、具体的な型定義や`unknown`を使用する
• Union型やIntersection型を活用して型安全性を向上させる
• 型ガードを使用して実行時の型チェックを行う
• オプショナルプロパティは`?`を使用し、`undefined`との違いを明確にする

### 関数とメソッド
• 関数は単一責任の原則に従い、一つの機能のみを持つように設計する
• 引数は3個以下に抑え、多い場合はオブジェクトで渡す
• 戻り値の型を明示的に指定し、`void`も含めて省略しない
• 非同期処理は`async/await`を使用し、Promiseチェーンを避ける

### エラーハンドリング
• try-catch文を適切に使用し、エラーの型を明確にする
• カスタムエラークラスを定義し、エラーの種類を区別する
• エラーは早期リターンやGuard clauseパターンで処理する
• リソースの確実な解放のためにfinallyブロックを活用する

### コメントとドキュメント
• JSDocコメントを使用して関数やクラスの説明を記述する
• コードの「なぜ」を説明するコメントを書き、「何を」は避ける
• TODO、FIXME、HACKなどの特殊コメントは期限や担当者を明記する
• 複雑なビジネスロジックには背景説明のコメントを追加する

### ファイル構成
• 一つのファイルには一つの主要なクラスまたは関数を配置する
• exportは明示的に行い、default exportとnamed exportを使い分ける
• 相対パスではなく絶対パスを使用してインポートを行う
• 未使用のインポートは削除し、インポート順序を統一する

### 設定とツール
• ESLintとPrettierを設定し、コードフォーマットを自動化する
• `strict`モードを有効にし、型チェックを厳格に行う
• `noImplicitAny`、`noImplicitReturns`などの厳格オプションを有効化する
• pre-commitフックを設定し、コミット前に自動チェックを実行する

TypeScriptにおけるログ設計の規約も追加します：

### ログレベル設計
• ログレベルは`ERROR`、`WARN`、`INFO`、`DEBUG`、`TRACE`の5段階で統一する
• 本番環境では`INFO`レベル以上、開発環境では`DEBUG`レベル以上を出力する
• `ERROR`は即座に対応が必要な障害、`WARN`は注意が必要だが処理は継続可能な状況で使用する
• `INFO`はビジネス的に重要な処理の開始・終了、`DEBUG`は開発時のデバッグ情報で使用する

#### ログメッセージ構造
• 構造化ログ（JSON形式）を使用し、検索・分析を容易にする
• 必須フィールドは`timestamp`、`level`、`message`、`traceId`、`userId`を含める
• エラーログには`error.name`、`error.message`、`error.stack`を含める
• 処理時間の計測が必要な場合は`duration`フィールドを追加する

#### ログメッセージ内容
• メッセージは動詞から始まり、何が起こったかを明確に記述する（例：「User authentication failed」）
• 個人情報（PII）は絶対にログに出力せず、必要な場合はマスキングやハッシュ化を行う
• パスワード、トークン、クレジットカード情報などの機密データは除外する
• ログメッセージは英語で統一し、日本語は避ける

#### ログ出力タイミング
• API呼び出しの開始時と終了時に必ずログを出力する
• データベース操作の前後でログを出力し、実行時間を記録する
• 外部サービス連携時は送信データと受信データをログに記録する
• エラー発生時は原因となった処理フローを追跡可能な情報を含める

#### トレーサビリティ
• 各リクエストに一意の`traceId`を付与し、全ログに含める
• 非同期処理でもコンテキスト情報を引き継ぎ、追跡可能にする
• 関連するログには`correlationId`を使用して処理の関連性を明確にする
• ユーザーアクションから発生した処理には`userId`を必須で含める

#### パフォーマンス考慮
• ログ出力は非同期処理で行い、メイン処理をブロックしない
• 大量のログが発生する処理では適切なサンプリングを実装する
• ログローテーションを設定し、ディスク容量を適切に管理する
• 本番環境では不要なDEBUGログを無効化してパフォーマンスを向上させる

#### 実装パターン
• ログライブラリ（winston、pino等）を使用し、直接のconsole.logは避ける
• 共通のログインターフェースを定義し、依存性注入で実装を差し替え可能にする
• エラーハンドリングとログ出力を組み合わせたDecoratorパターンを活用する
• テスト時はログ出力をモック化し、テストの独立性を保つ

## テスト方針
- 単体テスト: 各クラスの機能テスト